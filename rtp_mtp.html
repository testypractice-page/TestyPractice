<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TESTY</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<script src="rtp-mtp.js"></script>
  <!-- Font Awesome -->
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap">

<link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
<link rel="manifest" href="favicon/site.webmanifest">
<link rel="icon" type="image/png" sizes="192x192" href="favicon/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="512x512" href="favicon/android-chrome-512x512.png">
<link rel="shortcut icon" href="favicon/favicon.ico">

<link rel="stylesheet" href="style.css">
<style>
  .bookmark-btn{
    display: none;
  }
</style>
</head>
<body>
  <!-- ========== HEADER ========== -->
  <header class="top-bar">
    <div class="logo">TESTY</div>

    <!-- Desktop nav -->
    <nav class="top-nav">
      <a href="index.html">Home</a>
      <a href="auth.html">Login</a>
      <a href="rtp_mtp.html">RTP/MTP</a>
      <a href="settings.html">Settings</a>
      <a href="about.html">About</a>
      <a href="feedback.html">Drop Suggestion</a>
      <a href="sponsor.html">Sponsor</a>
    </nav>

    <div class="right-controls">
      <button class="top-btn" id="themeToggle">üåô</button>
      <button class="top-btn" id="menuBtn"><i class="fas fa-bars"></i></button>
    </div>
  </header>

  <!-- ========== LEFT SIDEBAR + HANDLE ========== -->
  <div class="left-handle" id="leftHandle"></div>

  <aside class="left-sidebar" id="leftSidebar">
    <ul class="left-list">
<li>
  <a href="profile.html" class="left-link">
    <span class="left-icon-box"><i class="fa-solid fa-user"></i></span>
    My Profile
  </a>
</li>

<li>
  <a href="bookmarks.html" class="left-link">
    <span class="left-icon-box"><i class="fa-solid fa-bookmark"></i></span>
    Bookmarks
  </a>
</li>

<li>
  <a href="#" class="left-link">
    <span class="left-icon-box"><i class="fa-solid fa-trophy"></i></span>
    Leaderboard
  </a>
</li>

<li>
  <a href="#" class="left-link">
    <span class="left-icon-box"><i class="fa-solid fa-comments"></i></span>
    Chatrooms
  </a>
</li>
<li>
  <a href="articles/How To Overcome Overthinking while exams.html" class="left-link">
    <span class="left-icon-box"><i class="fa-solid fa-note-sticky"></i></span>
    Article
  </a>
</li>
<li>
  <a href="wrongs.html" class="left-link">
    <span class="left-icon-box"><i class="fa-solid fa-pen-to-square"></i></span>
    Take a Correction Test
  </a>
</li>
    </ul>
  </aside>

  <div class="left-overlay" id="leftOverlay"></div>

  <!-- ========== RIGHT SIDEBAR ========== -->
  <aside class="right-sidebar" id="rightSidebar">
    <div class="right-header">
      <span>TESTY Menu</span>
      <button class="right-close" id="rightClose">‚úï</button>
    </div>
    <ul class="right-links">
      <li><a href="index.html">Home</a></li>
      <li><a href="auth.html">Login / Signup</a></li>
      <li class="nav-item" data-page="rtp"><a href="rtp_mtp.html">RTP/MTP</a></li>
      <li><a href="settings.html">Settings</a></li>
      <li><a href="about.html">About</a></li>
      <li><a href="sponsor.html">Sponsor Us</a></li>
      <li><a href="feedback.html">Drop Suggestion</a></li>
    </ul>
  </aside>

  <div class="right-overlay" id="rightOverlay"></div>

  <!-- ========== MAIN CONTENT ========== -->
<main>
  <section class="chapter-bar">
  <!-- SUBJECT -->
  <span class="chapter-label">Subject:</span>
  <button class="chapter-select" id="subjectSelectBtn" type="button">
    <span id="subjectSelectText">None Selected</span>
  </button>
  <div class="chapter-dropdown" id="subjectDropdown"></div>
  
      <span class="chapter-xp-label">
    XP: <span id="xpValue">00</span>
  </span>
</section>
  <!-- Chapter selection -->
  <section class="chapter-bar">
    <span class="chapter-label">Attempt:</span>

    <button class="chapter-select" id="chapterSelectBtn" type="button">
      <span id="chapterSelectText">None Selected</span>
    </button>

<div class="chapter-dropdown1" id="chapterDropdown">
  <!-- MTP group -->
  <div class="attempt-group" data-group="mtp">
    <div class="attempt-group-header">
      <input type="checkbox" class="attempt-check" />
      <span class="attempt-group-title">MTP</span>
    </div>
    <div class="attempt-group-body">
      <div class="attempt-option" data-attempt-id="mtp1-jan25">MTP I Jan 2025</div>
      <div class="attempt-option" data-attempt-id="mtp2-jan25">MTP II Jan 2025</div>
    </div>
  </div>

  <!-- RTP group -->
  <div class="attempt-group" data-group="rtp">
    <div class="attempt-group-header">
      <input type="checkbox" class="attempt-check" />
      <span class="attempt-group-title">RTP</span>
    </div>
    <div class="attempt-group-body">
      <div class="attempt-option" data-attempt-id="rtp-jan25">RTP Jan 2025</div>
      <div class="attempt-option" data-attempt-id="rtp-may25">RTP May 2025</div>
    </div>
  </div>
</div>
  </section>
<!-- ===== RTP / MTP attempt picker popup ===== -->

  <!-- Top: Best / Streak, Progress, Timer -->
<section class="mcq-top">
  <div class="mcq-progress-info">
    <div class="streak-row">
      <span id="bestStreak">Best: 0 | Streak: 0</span>

      <!-- NEW: In-order toggle -->
      <label class="order-toggle">
        <input type="checkbox" id="orderToggle">
        <span>In Order</span>
      </label>
    </div>

    <span id="questionCounter">0 / 0</span>
    <div class="mcq-progress-bar">
      <div class="mcq-progress-inner" id="mcqProgressInner"></div>
    </div>
  </div>

  <div class="mcq-timer">
    <span>Time:</span>
    <span id="timerDisplay">00:45</span>
  </div>
</section>

  <!-- Question + options (no card frame) -->
  <section class="mcq-card">
    <div class="mcq-question" id="mcqQuestionText">
      Click 'None Selected' to start.

    </div>
  <button class="bookmark-btn" id="bookmarkBtn" type="button">
      <i class="fa-regular fa-star"></i>
    </button>
    <div class="mcq-options" id="mcqOptionsContainer">
      <!-- options by JS -->
    </div>
  </section>

  <!-- Nav line: 3 equal parts -->
  <section class="mcq-nav">
    <button id="prevQuestionBtn" class="nav-btn" disabled>Previous</button>
    <span id="roundLabel" class="round-label">Round: 1</span>
    <button id="nextQuestionBtn" class="nav-btn" disabled>Next</button>
  </section>

  <hr class="marks-separator">

  <!-- Marks line (after quiz finished) -->
  <div class="marks-line">
    Marks: <span id="marksValue">--</span>
  </div>

  <!-- Review + PDF buttons -->
  <div class="review-actions">
    <button id="reviewBtn" class="small-btn" disabled>Review Questions</button>
    <button id="savePdfBtn" class="small-btn" disabled>Save as PDF</button>
  </div>

  <!-- Scrollable review area -->
  <section id="reviewSection" class="review-section">
    <!-- Filled by JS after quiz -->
  </section>
</main>
<!-- other scripts like fontawesome, style.css, etc. -->

  <!-- ========== SCRIPT ========== -->
<script>
(function () {
  /* ========== THEME ========== */
  const themeToggle = document.getElementById("themeToggle");
  const savedTheme  = localStorage.getItem("theme");
  if (savedTheme === "dark") document.body.classList.add("dark");
  if (themeToggle) {
    themeToggle.textContent = document.body.classList.contains("dark") ? "‚òÄÔ∏è" : "üåô";
    themeToggle.addEventListener("click", () => {
      const isDark = !document.body.classList.contains("dark");
      document.body.classList.toggle("dark", isDark);
      localStorage.setItem("theme", isDark ? "dark" : "light");
      themeToggle.textContent = isDark ? "‚òÄÔ∏è" : "üåô";
    });
  }



  // left-sidebar global setting
  const hideLS = localStorage.getItem("set_leftSidebarHidden") === "1";
  document.body.classList.toggle("hide-left-sidebar", hideLS);

  /* ========== RIGHT SIDEBAR ========== */
  const menuBtn      = document.getElementById("menuBtn");
  const rightSidebar = document.getElementById("rightSidebar");
  const rightOverlay = document.getElementById("rightOverlay");
  const rightClose   = document.getElementById("rightClose");

  function openRightSidebar() {
    if (!rightSidebar || !rightOverlay) return;
    rightSidebar.classList.add("open");
    rightOverlay.classList.add("show");
  }
  function closeRightSidebar() {
    if (!rightSidebar || !rightOverlay) return;
    rightSidebar.classList.remove("open");
    rightOverlay.classList.remove("show");
  }
  if (menuBtn)    menuBtn.addEventListener("click", openRightSidebar);
  if (rightClose) rightClose.addEventListener("click", closeRightSidebar);
  if (rightOverlay) rightOverlay.addEventListener("click", closeRightSidebar);

  /* ========== LEFT SIDEBAR + SWIPE ========== */
  const leftSidebar = document.getElementById("leftSidebar");
  const leftOverlay = document.getElementById("leftOverlay");
  const leftHandle  = document.getElementById("leftHandle");

  function openLeftSidebar() {
    if (!leftSidebar || !leftOverlay) return;
    leftSidebar.classList.add("open");
    leftOverlay.classList.add("show");
  }
  function closeLeftSidebar() {
    if (!leftSidebar || !leftOverlay) return;
    leftSidebar.classList.remove("open");
    leftOverlay.classList.remove("show");
  }
  if (leftHandle)  leftHandle.addEventListener("click", openLeftSidebar);
  if (leftOverlay) leftOverlay.addEventListener("click", closeLeftSidebar);

  // simple swipe
  let startX = null;
  if (leftHandle) {
    leftHandle.addEventListener("touchstart", e => {
      startX = e.touches[0].clientX;
    }, { passive: true });
    leftHandle.addEventListener("touchend", e => {
      if (startX == null) return;
      const diff = e.changedTouches[0].clientX - startX;
      if (diff > 40) openLeftSidebar();
      startX = null;
    }, { passive: true });
  }
  if (leftSidebar) {
    leftSidebar.addEventListener("touchstart", e => {
      startX = e.touches[0].clientX;
    }, { passive: true });
    leftSidebar.addEventListener("touchend", e => {
      if (startX == null) return;
      const diff = startX - e.changedTouches[0].clientX;
      if (diff > 40) closeLeftSidebar();
      startX = null;
    }, { passive: true });
  }

  /* ========== BOOKMARK STAR (same structure as index) ========== */
/* ========== BOOKMARK STAR (same structure as index) ========== */
/* ===== BOOKMARK HELPERS (shared, same behaviour as index.html) ===== */
const bookmarkBtn = document.getElementById("bookmarkBtn");
const BOOKMARK_KEY = "quizBookmarks";

/** return array of { attemptId, chapterId?, baseIndex } */
function loadBookmarks() {
  try {
    const raw = localStorage.getItem(BOOKMARK_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    return Array.isArray(arr) ? arr : [];
  } catch (err) {
    return [];
  }
}
function saveBookmarks(list) {
  try {
    localStorage.setItem(BOOKMARK_KEY, JSON.stringify(list));
  } catch (e) { /* ignore */ }
}
function isBookmarked(attemptId, baseIndex) {
  return loadBookmarks().some(b => b.attemptId === attemptId && b.baseIndex === baseIndex);
}
function toggleBookmark(attemptId, baseIndex) {
  const list = loadBookmarks();
  const idx = list.findIndex(b => b.attemptId === attemptId && b.baseIndex === baseIndex);
  if (idx >= 0) {
    list.splice(idx, 1);
  } else {
    list.push({ attemptId, baseIndex });
  }
  saveBookmarks(list);
}

/* ================= XP SYSTEM (shared with index.html) ================= */
const XP_KEY = "quizXP";
const XP_AWARDED_KEY = "quizXpAwarded";
const DAILY_XP_KEY      = "quizDailyXp";
const STREAK_KEY        = "quizDayStreak";
const LAST_DAY_KEY      = "quizLastXpDate";
const MOST_DAILY_XP_KEY = "quizMostDailyXp";

function loadDailyXp() {
  try {
    const raw = localStorage.getItem(DAILY_XP_KEY);
    const obj = raw ? JSON.parse(raw) : {};
    return obj && typeof obj === "object" ? obj : {};
  } catch {
    return {};
  }
}

let dailyXp = loadDailyXp();

let dayStreak = parseInt(localStorage.getItem(STREAK_KEY), 10);
if (isNaN(dayStreak) || dayStreak < 0) dayStreak = 0;

let lastXpDate = localStorage.getItem(LAST_DAY_KEY) || null;

let mostDailyXp = parseInt(localStorage.getItem(MOST_DAILY_XP_KEY), 10);
if (isNaN(mostDailyXp) || mostDailyXp < 0) mostDailyXp = 0;

function getTodayKey() {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const day = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${day}`;
}

function saveDailyXp() {
  try {
    localStorage.setItem(DAILY_XP_KEY, JSON.stringify(dailyXp));
  } catch (e) {
    // ignore quota errors
  }
}

function updateDailyXpAndStreak(delta) {
  if (!delta || delta <= 0) return;

  const today = getTodayKey();
  const prev  = dailyXp[today] || 0;
  const next  = prev + delta;
  dailyXp[today] = next;
  saveDailyXp();

  if (prev === 0 && next > 0) {
    if (!lastXpDate) {
      dayStreak = 1;
    } else {
      if (lastXpDate !== today) {
        const last = new Date(lastXpDate);
        const cur  = new Date(today);
        const diffMs   = cur - last;
        const diffDays = Math.round(diffMs / 86400000);
        if (diffDays === 1) {
          dayStreak += 1;
        } else {
          dayStreak = 1;
        }
      }
    }
    lastXpDate = today;
    localStorage.setItem(LAST_DAY_KEY, lastXpDate);
    localStorage.setItem(STREAK_KEY, String(dayStreak));
  }

  if (next > mostDailyXp) {
    mostDailyXp = next;
    localStorage.setItem(MOST_DAILY_XP_KEY, String(mostDailyXp));
  }
}
const xpDisplay = document.getElementById("xpValue");

function loadXP() {
  const v = parseInt(localStorage.getItem(XP_KEY), 10);
  return isNaN(v) ? 0 : v;
}

let xp = loadXP();

function updateXpUI() {
  if (!xpDisplay) return;
  xpDisplay.textContent = String(xp).padStart(2, "0");
}

function saveXP() {
  localStorage.setItem(XP_KEY, String(xp));
  updateXpUI();
}
// ---------- XP toast (Transferred!) ----------
function showXpTransferredToast() {
  const el = document.getElementById("xpToast");
  if (!el) return;
  el.classList.add("show");
  setTimeout(() => {
    el.classList.remove("show");
  }, 2200);
}

// ---------- main XP grant helper ----------
function grantXP(delta) {
  if (!delta || delta <= 0) return;
  
  // screen XP (0‚Äì99)
  xp += delta;
  let transferred = false;
  
  // if went over/equals 100 ‚Üí wrap down and mark transferred
  while (xp >= 100) {
    xp -= 100;
    transferred = true;
  }
  
  // save wrapped XP for the header
  saveXP();
  
  // but stats/profile should get FULL delta
  updateDailyXpAndStreak(delta);
  
  if (transferred) {
    showXpTransferredToast();
  }
}
// per-question XP guard (same question se bar-bar XP na mile)
function loadXpAwarded() {
  try {
    const raw = localStorage.getItem(XP_AWARDED_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    return Array.isArray(arr) ? arr : [];
  } catch {
    return [];
  }
}

let xpAwardedList = loadXpAwarded();

function saveXpAwarded() {
  localStorage.setItem(XP_AWARDED_KEY, JSON.stringify(xpAwardedList));
}

function hasXpAward(subjectId, chapterId, baseIndex) {
  return xpAwardedList.some(
    e =>
      e.subjectId === subjectId &&
      e.chapterId === chapterId &&
      e.baseIndex === baseIndex
  );
}

function markXpAward(subjectId, chapterId, baseIndex) {
  if (hasXpAward(subjectId, chapterId, baseIndex)) return;
  xpAwardedList.push({ subjectId, chapterId, baseIndex });
  saveXpAwarded();
}

// first paint of XP
updateXpUI();

  /* ========== SETTINGS HELPERS (timer etc.) ========== */
  /* ========== SETTINGS HELPERS (timer etc.) ========== */
const QUESTION_TIME_DEFAULT = 45;
function getQuestionTime() {
  // key aligned with settings.html: set_questionTimeSeconds
  const v = parseInt(localStorage.getItem("set_questionTimeSeconds"), 10);
  if (!isNaN(v) && v >= 30) return v;
  return QUESTION_TIME_DEFAULT;
}
  function getBoolSetting(key, def = true) {
    const v = localStorage.getItem(key);
    if (v === null) return def;
    return v === "1";
  }

// ===== RTP/MTP EXAM MODE (100Q = 120 mins) =====
  const EXAM_TOTAL_SECONDS = 120 * 60; // 120 minutes
  const EXAM_MODE_KEY      = "set_rtpMtpExamMode";

  // read flag from settings
  const examModeOn = localStorage.getItem(EXAM_MODE_KEY) === "1";

  // global exam timer (full paper)
  let examTimerInterval = null;
  let examTimeRemaining = EXAM_TOTAL_SECONDS;

  /* ========== STATE ========== */
  let currentAttempt   = null;   // object from rtpMtpAttempts
  let baseQuestions    = [];
  let currentQuestions = [];
  let currentIndex     = 0;
  let answers          = [];
  let mastered         = [];
  let firstRoundAns    = [];
  let attemptedFirst   = 0;

  let roundNumber      = 1;
  let quizFinished     = false;
  let marksCorrectFirst= 0;
  let marksWrongFirst  = 0;
  let marks            = null;
  let currentStreak    = 0;
  let bestStreak       = 0;

  let timerInterval    = null;
  let timeRemaining    = getQuestionTime();
  let autoNextTimeout  = null;

  // settings cache
  let cfg_randomizeQuestions = getBoolSetting("set_randomizeQuestions", true);
  let cfg_randomizeOptions   = getBoolSetting("set_randomizeOptions", true);
  let cfg_showLetters        = getBoolSetting("set_showLetters", true);
  let cfg_timerOn            = getBoolSetting("set_timerOn", true);
  let cfg_autoSkip           = getBoolSetting("set_autoSkip", true);

  /* ========== DOM ========== */
  const chapterSelectBtn   = document.getElementById("chapterSelectBtn");
  const chapterSelectText  = document.getElementById("chapterSelectText");
  const chapterDropdown    = document.getElementById("chapterDropdown");

  const orderToggle        = document.getElementById("orderToggle");
  const mcqQuestionText    = document.getElementById("mcqQuestionText");
  const mcqOptionsContainer= document.getElementById("mcqOptionsContainer");
  const questionCounter    = document.getElementById("questionCounter");
  const progressInner      = document.getElementById("mcqProgressInner");
  const timerDisplay       = document.getElementById("timerDisplay");
  const prevBtn            = document.getElementById("prevQuestionBtn");
  const nextBtn            = document.getElementById("nextQuestionBtn");
  const roundLabel         = document.getElementById("roundLabel");
  const bestStreakSpan     = document.getElementById("bestStreak");
  const marksValue         = document.getElementById("marksValue");
  const markSep            = document.querySelector(".marks-separator");
  const marksLine          = document.querySelector(".marks-line");
  const reviewActions      = document.querySelector(".review-actions");
  const reviewBtn          = document.getElementById("reviewBtn");
  const savePdfBtn         = document.getElementById("savePdfBtn");
  const reviewSection      = document.getElementById("reviewSection");

  if (timerDisplay) timerDisplay.textContent = "--";

  /* ========== UTILS ========== */
  function shuffleArray(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
  }
  
// Decide final option order for a question,
// with special rules for All / None / Any / Both / Either / Neither
function computeOptionOrder(options, allowRandom) {
  const count = options.length;
  const indices = Array.from({ length: count }, (_, i) => i);

  // If randomisation is globally OFF, keep the original order
  if (!allowRandom) return indices;

  // Classify option by its starting word
  function classify(text) {
    const t = text.trim().toLowerCase();
    if (t.startsWith("all")) return "all";
    if (t.startsWith("none")) return "none";
    if (t.startsWith("any")) return "any";
    if (t.startsWith("both")) return "both";
    if (t.startsWith("either")) return "either";
    if (t.startsWith("neither")) return "neither";
    return "normal";
  }

  const allIdx = [];
  const noneIdx = [];
  const anyIdx = [];
  const bothIdx = [];
  const eitherIdx = [];
  const neitherIdx = [];
  const normalIdx = [];

  indices.forEach(i => {
    const type = classify(options[i]);
    switch (type) {
      case "all":     allIdx.push(i);     break;
      case "none":    noneIdx.push(i);    break;
      case "any":     anyIdx.push(i);     break;
      case "both":    bothIdx.push(i);    break;
      case "either":  eitherIdx.push(i);  break;
      case "neither": neitherIdx.push(i); break;
      default:        normalIdx.push(i);  break;
    }
  });

  // Helper: single special option must always be last (4th)
  function placeSingleAtEnd(specialIdx) {
    const others = indices.filter(i => i !== specialIdx);
    shuffleArray(others);          // uses your existing helper
    others.push(specialIdx);       // special goes to last position
    return others;
  }

  // Helper: two specials fixed at 3rd + 4th positions
  // (idxThird at 3rd place, idxFourth at 4th place)
  function placeThirdAndFourth(idxThird, idxFourth) {
    // assume 4 options
    const remaining = indices.filter(i => i !== idxThird && i !== idxFourth);
    shuffleArray(remaining);       // fill 1st and 2nd randomly
    return [remaining[0], remaining[1], idxThird, idxFourth];
  }

  // ====== RULE 4: Both + Neither ‚Üí Both at 3rd, Neither at 4th ======
  if (bothIdx.length === 1 && neitherIdx.length === 1) {
    return placeThirdAndFourth(bothIdx[0], neitherIdx[0]);
  }

  // ====== RULE 5: Either + Neither ‚Üí Either at 3rd, Neither at 4th ======
  if (eitherIdx.length === 1 && neitherIdx.length === 1) {
    return placeThirdAndFourth(eitherIdx[0], neitherIdx[0]);
  }

  // ====== RULE 7: Both + None ‚Üí Both at 3rd, None at 4th ======
  if (bothIdx.length === 1 && noneIdx.length === 1) {
    return placeThirdAndFourth(bothIdx[0], noneIdx[0]);
  }

  // ====== RULE 6: Only ONE "Both" and other 3 are normal ‚Üí keep as is (no shuffle) ======
  if (
    bothIdx.length === 1 &&
    allIdx.length === 0 &&
    noneIdx.length === 0 &&
    anyIdx.length === 0 &&
    eitherIdx.length === 0 &&
    neitherIdx.length === 0
  ) {
    return indices; // original order
  }

  // ====== RULE 1: Only ONE option starting with "All" ‚Üí always 4th ======
  if (
    allIdx.length === 1 &&
    noneIdx.length === 0 &&
    anyIdx.length === 0 &&
    bothIdx.length === 0 &&
    eitherIdx.length === 0 &&
    neitherIdx.length === 0
  ) {
    return placeSingleAtEnd(allIdx[0]);
  }

  // ====== RULE 2: Only ONE option starting with "None" ‚Üí always 4th ======
  if (
    noneIdx.length === 1 &&
    allIdx.length === 0 &&
    anyIdx.length === 0 &&
    bothIdx.length === 0 &&
    eitherIdx.length === 0 &&
    neitherIdx.length === 0
  ) {
    return placeSingleAtEnd(noneIdx[0]);
  }

  // ====== RULE 3: Only ONE option starting with "Any" ‚Üí always 4th ======
  if (
    anyIdx.length === 1 &&
    allIdx.length === 0 &&
    noneIdx.length === 0 &&
    bothIdx.length === 0 &&
    eitherIdx.length === 0 &&
    neitherIdx.length === 0
  ) {
    return placeSingleAtEnd(anyIdx[0]);
  }

  // ====== Extra: Only ONE "Neither" and others normal ‚Üí always 4th ======
  if (
    neitherIdx.length === 1 &&
    allIdx.length === 0 &&
    noneIdx.length === 0 &&
    anyIdx.length === 0 &&
    bothIdx.length === 0 &&
    eitherIdx.length === 0
  ) {
    return placeSingleAtEnd(neitherIdx[0]);
  }

  // ====== Default: normal shuffle for everything else ======
  const shuffled = [...indices];
  shuffleArray(shuffled);
  return shuffled;
}

function formatSecondsMode(sec) {
    // normal style: "45s"
    return `${sec}s`;
  }

  function formatMinutesMode(sec) {
    // exam mode style: "MM:SS"
    const m = Math.floor(sec / 60).toString().padStart(2, "0");
    const s = (sec % 60).toString().padStart(2, "0");
    return `${m}:${s}`;
  }

  function formatTime(sec) {
    // used wherever timerDisplay is set
    if (examModeOn) {
      return formatMinutesMode(sec);
    }
    return formatSecondsMode(sec);
  }

  function clearTimer() {
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = null;
  }
  function clearAutoNext() {
    if (autoNextTimeout) clearTimeout(autoNextTimeout);
    autoNextTimeout = null;
  }
  function setLiveQuestionBorder(color) {
    const card = mcqOptionsContainer?.closest(".mcq-card");
    if (!card) return;
    if (color) {
      card.style.border = `1px solid ${color}`;
      card.style.borderRadius = "12px";
      card.style.padding = "10px";
    } else {
      card.style.border = "";
    }
  }
  function computeMarks() {
    return marksCorrectFirst * 1 + marksWrongFirst * -0.25;
  }
  function updateProgress() {
    if (!questionCounter || !progressInner || !baseQuestions.length) {
      if (questionCounter) questionCounter.textContent = "0 / 0";
      if (progressInner) progressInner.style.width = "0%";
      return;
    }
    const total = baseQuestions.length;
    const attempted = attemptedFirst;
    questionCounter.textContent = `${attempted} / ${total}`;
    const pct = (attempted / total) * 100;
    progressInner.style.width = `${pct}%`;
  }
  function updateStats() {
    if (bestStreakSpan) {
      bestStreakSpan.textContent = `Best: ${bestStreak} | Streak: ${currentStreak}`;
    }
    if (roundLabel) {
      roundLabel.textContent = roundNumber === 1 ? "Round 1" : "Retrying round";
    }
    if (marksValue) {
      marksValue.textContent = marks == null ? "--" : `${marks.toFixed(2)} M`;
    }
  }
  function resetSummaryUI() {
    if (markSep)       markSep.style.display = "none";
    if (marksLine)     marksLine.style.display = "none";
    if (reviewActions) reviewActions.style.display = "none";
    if (reviewBtn)     reviewBtn.disabled = true;
    if (savePdfBtn)    savePdfBtn.disabled = true;
    if (reviewSection) {
      reviewSection.style.display = "none";
      reviewSection.innerHTML = "";
    }
  }


// ========== SUBJECT DROPDOWN (uses rtpMtpSubjects) ==========
  const subjectSelectBtn  = document.getElementById("subjectSelectBtn");
  const subjectSelectText = document.getElementById("subjectSelectText");
  const subjectDropdown   = document.getElementById("subjectDropdown");

  let currentSubject = null; // { id, name, attempts[] }

  function selectSubject(subjectId) {
    if (!Array.isArray(rtpMtpSubjects)) return;

    const sub = rtpMtpSubjects.find(s => s.id === subjectId);
    if (!sub) return;

    currentSubject = sub;

    if (subjectSelectText) subjectSelectText.textContent = sub.name;
    if (chapterSelectText) chapterSelectText.textContent = "None Selected";

    // reset quiz state
    currentAttempt      = null;
    baseQuestions       = [];
    currentQuestions    = [];
    currentIndex        = 0;
    answers             = [];
    mastered            = [];
    firstRoundAns       = [];
    attemptedFirst      = 0;
    roundNumber         = 1;
    quizFinished        = false;
    marksCorrectFirst   = 0;
    marksWrongFirst     = 0;
    marks               = null;
    currentStreak       = 0;
    bestStreak          = 0;

    clearTimer();
    clearAutoNext();
    if (timerDisplay) timerDisplay.textContent = "--";

    resetSummaryUI();
    updateStats();
    updateProgress();
    renderQuestion();   // ‚ÄúSelect an attempt to start.‚Äù

    buildAttemptDropdown();
  }

  function buildAttemptDropdown() {
    if (!chapterDropdown || !currentSubject) return;

    const mtpBody = chapterDropdown.querySelector(
      '.attempt-group[data-group="mtp"] .attempt-group-body'
    );
    const rtpBody = chapterDropdown.querySelector(
      '.attempt-group[data-group="rtp"] .attempt-group-body'
    );

    if (mtpBody) mtpBody.innerHTML = "";
    if (rtpBody) rtpBody.innerHTML = "";

    (currentSubject.attempts || []).forEach(att => {
      const body = att.type === "RTP" ? rtpBody : mtpBody;
      if (!body) return;

      const opt = document.createElement("div");
      opt.className = "attempt-option";
      opt.dataset.attemptId = att.id;
      opt.textContent = att.name;

      opt.addEventListener("click", () => {
        if (chapterSelectText) chapterSelectText.textContent = att.name;
        closeChapterDropdown();
        startAttempt(att.id);
      });

      body.appendChild(opt);
    });

    // reset group open/close & checkboxes
    chapterDropdown.querySelectorAll(".attempt-check").forEach(cb => {
      cb.checked = false;
    });
    chapterDropdown.querySelectorAll(".attempt-group").forEach(g => {
      g.classList.remove("active");
    });
  }

  // open/close subject dropdown & populate it
  if (subjectSelectBtn && subjectDropdown) {
    subjectSelectBtn.addEventListener("click", e => {
      e.stopPropagation();
      subjectDropdown.classList.toggle("show");
    });

    document.addEventListener("click", e => {
      if (!subjectSelectBtn.contains(e.target) &&
          !subjectDropdown.contains(e.target)) {
        subjectDropdown.classList.remove("show");
      }
    });

    if (Array.isArray(rtpMtpSubjects) && rtpMtpSubjects.length) {
      subjectDropdown.innerHTML = "";
      rtpMtpSubjects.forEach(sub => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "chapter-option";
        btn.textContent = sub.name;
        btn.addEventListener("click", () => {
          subjectDropdown.classList.remove("show");
          selectSubject(sub.id);
        });
        subjectDropdown.appendChild(btn);
      });

      // optional: pre-select first subject
      selectSubject(rtpMtpSubjects[0].id);
    }
  }
  
  /* ========== TIMER ========== */
function startTimerForCurrentQuestion() {
    cfg_timerOn = getBoolSetting("set_timerOn", true);

    if (!cfg_timerOn) {
      clearTimer();
      if (timerDisplay) timerDisplay.textContent = "--";
      return;
    }
    if (!timerDisplay) return;

    // always stop any old timers
    clearTimer();
    clearAutoNext();

    // if quiz is over or no question, just show nothing
    if (quizFinished || !currentQuestions.length || answers[currentIndex] !== null) {
      timerDisplay.textContent = "--";
      return;
    }

    // =====================
    //  EXAM MODE ON ‚Üí one big 120-min timer
    // =====================
    if (examModeOn) {
      // start only once, on first question
      if (!examTimerInterval) {
        examTimeRemaining = EXAM_TOTAL_SECONDS;
        timerDisplay.textContent = formatTime(examTimeRemaining);

        examTimerInterval = setInterval(() => {
          examTimeRemaining--;
          timerDisplay.textContent = formatTime(examTimeRemaining);

          if (examTimeRemaining <= 0) {
            clearInterval(examTimerInterval);
            examTimerInterval = null;
            // Time over for full RTP/MTP paper
            endQuiz();  // use your existing endQuiz() for RTP/MTP
          }
        }, 1000);
      } else {
        // timer already running, just update display
        timerDisplay.textContent = formatTime(examTimeRemaining);
      }

      // IMPORTANT: return here so per-question 45s timer is NOT used
      return;
    }

    // =====================
    //  NORMAL MODE ‚Üí 45s per question
    // =====================
    QUESTION_TIME = getQuestionTime();
    timeRemaining = QUESTION_TIME;
    timerDisplay.textContent = formatTime(timeRemaining);

    timerInterval = setInterval(() => {
      timeRemaining--;
      timerDisplay.textContent = formatTime(timeRemaining);
      if (timeRemaining <= 0) {
        clearTimer();
        handleTimeUp();   // your existing per-question timeout logic
      }
    }, 1000);
  }

  /* ========== DROPDOWN (attempt picker) ========== */
  function closeChapterDropdown() {
    chapterDropdown?.classList.remove("show");
  }

  if (chapterSelectBtn && chapterDropdown) {
    chapterSelectBtn.addEventListener("click", e => {
      e.stopPropagation();
      chapterDropdown.classList.toggle("show");
    });
    document.addEventListener("click", e => {
      if (!chapterDropdown.contains(e.target) &&
          !chapterSelectBtn.contains(e.target)) {
        closeChapterDropdown();
      }
    });




    // checkbox itself also controls open/close
// checkbox: only one group open at a time
    const checks = chapterDropdown.querySelectorAll(".attempt-check");
    checks.forEach(cb => {
      cb.addEventListener("change", () => {
        const group = cb.closest(".attempt-group");
        if (!group) return;

        if (cb.checked) {
          // close all others
          checks.forEach(other => {
            if (other !== cb) {
              other.checked = false;
              const og = other.closest(".attempt-group");
              if (og) og.classList.remove("active");
            }
          });
          group.classList.add("active");
        } else {
          group.classList.remove("active");
        }
      });
    });

    // selecting an attempt option
    const attemptOptions = chapterDropdown.querySelectorAll(".attempt-option");
    attemptOptions.forEach(opt => {
      opt.addEventListener("click", () => {
        const attemptId = opt.dataset.attemptId;
        const label     = opt.textContent.trim();
        if (chapterSelectText) chapterSelectText.textContent = label;
        closeChapterDropdown();
        startAttempt(attemptId);
      });
    });
  }

  if (orderToggle) {
    orderToggle.addEventListener("change", () => {
      cfg_randomizeQuestions = !orderToggle.checked ? true : false;
      if (currentAttempt) startAttempt(currentAttempt.id);
    });
  }

  /* ========== LOAD ATTEMPT ========== */
function startAttempt(attemptId) {
    if (!Array.isArray(rtpMtpSubjects)) return;

    // try within currentSubject first
    let foundSubject = currentSubject;
    let att = null;

    if (foundSubject) {
      att = (foundSubject.attempts || []).find(a => a.id === attemptId);
    }

    // if not found (or no subject selected), search all subjects
    if (!att) {
      for (const sub of rtpMtpSubjects) {
        const candidate = (sub.attempts || []).find(a => a.id === attemptId);
        if (candidate) {
          foundSubject = sub;
          att = candidate;
          break;
        }
      }
    }

    if (!att || !foundSubject) return;

    currentSubject = foundSubject;
    currentAttempt = att;

    if (subjectSelectText) subjectSelectText.textContent = currentSubject.name;

    // build baseQuestions from that attempt
    baseQuestions = att.questions.map((q, idx) => ({
      ...q,
      _baseIndex: idx
    }));
    mastered = Array(baseQuestions.length).fill(false);

    cfg_randomizeQuestions = getBoolSetting("set_randomizeQuestions", true);
    const inOrder = orderToggle && orderToggle.checked;

    currentQuestions = [...baseQuestions];
    if (cfg_randomizeQuestions && !inOrder) {
      shuffleArray(currentQuestions);
    }

    currentIndex      = 0;
    answers           = Array(currentQuestions.length).fill(null);
    firstRoundAns     = Array(baseQuestions.length).fill(null);
    attemptedFirst    = 0;
    roundNumber       = 1;
    quizFinished      = false;
    marksCorrectFirst = 0;
    marksWrongFirst   = 0;
    marks             = null;
    currentStreak     = 0;
    bestStreak        = 0;

    if (prevBtn) prevBtn.disabled = true;
    if (nextBtn) nextBtn.disabled = true;

    resetSummaryUI();
    updateStats();
    updateProgress();
    renderQuestion();
    startTimerForCurrentQuestion();
  }

  /* ========== RENDER QUESTION ========== */
  function renderQuestion() {
    if (!mcqQuestionText || !mcqOptionsContainer) return;
    const q = currentQuestions[currentIndex];

    setLiveQuestionBorder(null);

    if (!q) {
      mcqQuestionText.textContent = "Select an attempt to start.";
      mcqOptionsContainer.innerHTML = "";
      if (prevBtn) prevBtn.disabled = true;
      if (nextBtn) nextBtn.disabled = true;
      return;
    }

    mcqQuestionText.textContent = `${currentIndex + 1}. ${q.text}`;
    mcqOptionsContainer.innerHTML = "";

// ------- bookmark button handling (renderQuestion)
if (bookmarkBtn && currentAttempt && q && q._baseIndex != null) {
  bookmarkBtn.style.display = "inline-flex";
  // handle visual active state
  const active = isBookmarked(currentAttempt.id, q._baseIndex);
  bookmarkBtn.classList.toggle("active", active);

  // ensure icon markup inside button is the same as index (use <i> element)
  let icon = bookmarkBtn.querySelector("i");
  if (!icon) {
    bookmarkBtn.innerHTML = '<i class="fa-regular fa-star"></i>';
    icon = bookmarkBtn.querySelector("i");
  }
  // toggle solid/regular class
  icon.classList.toggle("fa-solid", active);
  icon.classList.toggle("fa-regular", !active);

  // click handler
  bookmarkBtn.onclick = () => {
    toggleBookmark(currentAttempt.id, q._baseIndex);
    const nowActive = isBookmarked(currentAttempt.id, q._baseIndex);
    bookmarkBtn.classList.toggle("active", nowActive);
    // update icon style
    icon.classList.toggle("fa-solid", nowActive);
    icon.classList.toggle("fa-regular", !nowActive);
  };
} else if (bookmarkBtn) {
  // hide when no question
  bookmarkBtn.style.display = "none";
  bookmarkBtn.classList.remove("active");
  bookmarkBtn.onclick = null;
  // keep a predictable icon state
  if (bookmarkBtn.querySelector("i")) {
    bookmarkBtn.querySelector("i").classList.remove("fa-solid");
    bookmarkBtn.querySelector("i").classList.add("fa-regular");
  }
}

    const savedAnswer = answers[currentIndex];
    cfg_randomizeOptions = getBoolSetting("set_randomizeOptions", true);
    cfg_showLetters      = getBoolSetting("set_showLetters", true);

    // Decide order once per question, with special-case rules
    // ---------- Option ordering with special-rule handling ----------
function computeOptionOrderForQuestion(q, cfg_randomizeOptions, shuffleFn) {
  const n = q.options.length;
  const idxs = q.options.map((_, i) => i);
  const txts = q.options.map(o => (o || "").toString().toLowerCase().trim());

  // helper regexes
  const reAll = /\ball of the above\b/;
  const reNone = /\bnone of the above\b/;
  const reBothAB = /\bboth\s*\(?.?a.?\)?\s*(?:and|&)\s*\(?.?b.?\)?\b|both\s*a\s*and\s*b\b/i;
  const reNeitherAB = /\bneither\s*\(?.?a.?\)?\s*(?:nor)\s*\(?.?b.?\)?\b|neither\s*a\s*nor\s*b\b/i;
  const reBoth12 = /\bboth\s*\(?.?1.?\)?\s*(?:and|&)\s*\(?.?2.?\)?\b|both\s*1\s*and\s*2\b/i;

  // find indices
  const allIdxs = [];
  const noneIdxs = [];
  const bothABIdxs = [];
  const neitherIdxs = [];
  const both12Idxs = [];

  for (let i = 0; i < n; i++) {
    const s = txts[i];
    if (reAll.test(s)) allIdxs.push(i);
    if (reNone.test(s)) noneIdxs.push(i);
    if (reBothAB.test(s)) bothABIdxs.push(i);
    if (reNeitherAB.test(s)) neitherIdxs.push(i);
    if (reBoth12.test(s)) both12Idxs.push(i);
  }

  // RULES that force "no randomization":
  // 6) only (a) and (b) => no randomize (we treat as two-options or explicit 'only (a)' text)
  // 7) if question includes 'both (a) and (b)' => do not randomize
  // 8) both (1) and (2) => do not randomize
  // 9) if includes None + Both ‚Äî avoid randomization (safe)
  const onlyAandB = (() => {
    // if there are exactly 2 options and they reference (a) and (b) patterns -> don't randomize
    if (n === 2) {
      const aPattern = /\(?a\)?/i;
      const bPattern = /\(?b\)?/i;
      const hasA = aPattern.test(txts[0]) || aPattern.test(txts[1]);
      const hasB = bPattern.test(txts[0]) || bPattern.test(txts[1]);
      if (hasA && hasB) return true;
    }
    // also if options explicitly say "only (a)" and "only (b)" or the like
    const onlyAPattern = /\bonly\s*\(?.?a.?\)?\b/i;
    const onlyBPattern = /\bonly\s*\(?.?b.?\)?\b/i;
    if (onlyAPattern.test(txts.join(" ")) && onlyBPattern.test(txts.join(" "))) return true;

    return false;
  })();

  const hasBothAB = bothABIdxs.length > 0 || both12Idxs.length > 0;
  const hasNoneAndBoth = (noneIdxs.length > 0 && (bothABIdxs.length > 0 || both12Idxs.length > 0));

  if (onlyAandB || hasBothAB || both12Idxs.length > 0 || hasNoneAndBoth) {
    // return default order (no randomization)
    return idxs;
  }

  // For normal questions: we will randomize pool but preserve special positions.
  // Create pools: normalPool (shuffled), then append both/ neither / all/ none respecting priority rules.
  const reserved = new Set();
  allIdxs.forEach(i => reserved.add(i));
  noneIdxs.forEach(i => reserved.add(i));
  bothABIdxs.forEach(i => reserved.add(i));
  neitherIdxs.forEach(i => reserved.add(i));
  both12Idxs.forEach(i => reserved.add(i));

  const normalPool = idxs.filter(i => !reserved.has(i));

  // if randomization disabled return canonical order (but still move special ones to end positions)
  if (!cfg_randomizeOptions) {
    // canonical: normalPool (in original order), then both, then neither, then all/none
    const out = [];
    normalPool.forEach(i => out.push(i));
    bothABIdxs.forEach(i => out.push(i));
    neitherIdxs.forEach(i => out.push(i));
    // place 'none' and 'all' at the absolute end; keep relative order among them as original
    noneIdxs.forEach(i => out.push(i));
    allIdxs.forEach(i => out.push(i));
    return out;
  }

  // shuffle normal pool
  if (typeof shuffleFn === "function") shuffleFn(normalPool);

  // build final order:
  const order = [];
  normalPool.forEach(i => order.push(i));

  // Ensure: if both & neither present -> both placed before neither
  bothABIdxs.forEach(i => order.push(i));
  neitherIdxs.forEach(i => order.push(i));

  // 'none of the above' and 'all of the above' should be last (all/none both to the end)
  noneIdxs.forEach(i => {
    // if it was already pushed above, remove earlier occurrence and re-push to ensure last
    const pos = order.indexOf(i);
    if (pos !== -1) order.splice(pos, 1);
    order.push(i);
  });
  allIdxs.forEach(i => {
    const pos = order.indexOf(i);
    if (pos !== -1) order.splice(pos, 1);
    order.push(i);
  });

  // final safety: ensure length matches
  if (order.length !== n) {
    // fallback to default
    return idxs;
  }
  return order;
}

// ------------------ REPLACE the old q._optionOrder block with this ------------------
// (put this code where you previously had: if (!q._optionOrder) { ... shuffle ... })
if (!q._optionOrder) {
  // compute order with special rules
  q._optionOrder = computeOptionOrderForQuestion(q, cfg_randomizeOptions, shuffleArray);
}

    q._optionOrder.forEach((optIndex, pos) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "mcq-option-btn";
      btn.dataset.idx = String(optIndex);

      const letter = String.fromCharCode(65 + pos);
      const letterHTML = cfg_showLetters
        ? `<span class="opt-letter">${letter}.</span>`
        : "";

      btn.innerHTML = `${letterHTML}<span class="opt-text">${q.options[optIndex]}</span>`;

      if (savedAnswer != null) {
        const isCorrectOpt = optIndex === q.correctIndex;
        const isSelected   = optIndex === savedAnswer;

        if (isCorrectOpt) btn.classList.add("correct");
        if (isSelected && !isCorrectOpt) btn.classList.add("wrong");
        if (!isSelected && !isCorrectOpt) btn.classList.add("dimmed");
        btn.disabled = true;
      } else {
        btn.addEventListener("click", () => handleOptionClick(optIndex));
      }

      mcqOptionsContainer.appendChild(btn);
    });

    if (prevBtn) prevBtn.disabled = (currentIndex === 0);
    if (nextBtn) {
      if (!quizFinished) nextBtn.disabled = (answers[currentIndex] == null);
      else nextBtn.disabled = (currentIndex === currentQuestions.length - 1);
    }

    updateProgress();
    updateStats();
  }

  /* ========== ANSWER CLICK ========== */
/* ========== ANSWER CLICK (with XP +3) ========== */
function handleOptionClick(selectedIdx) {
  if (quizFinished || !currentQuestions.length) return;
  const q = currentQuestions[currentIndex];
  if (!q || answers[currentIndex] != null) return;

  clearTimer();
  clearAutoNext();

  const isCorrect = selectedIdx === q.correctIndex;

  // --- XP: +3 only first correct time for this question ---
  // --- XP: +3 only first correct time for this question (RTP/MTP) ---
// --- XP: +3 only first correct time for this question ---
  

// XP: +3 EVERY time user answers correctly (RTP/MTP)
if (isCorrect) {
  grantXP(3);
}

  if (isCorrect && q._baseIndex != null) {
    mastered[q._baseIndex] = true;
  }

  setLiveQuestionBorder(isCorrect ? "#4caf50" : "#e53935");
  answers[currentIndex] = selectedIdx;

  const buttons = mcqOptionsContainer.querySelectorAll(".mcq-option-btn");
  buttons.forEach(btn => {
    const idx = parseInt(btn.dataset.idx, 10);
    const isCorrectOpt = idx === q.correctIndex;
    const isSelected   = idx === selectedIdx;

    if (isCorrectOpt) btn.classList.add("correct");
    if (isSelected && !isCorrectOpt) btn.classList.add("wrong");
    if (!isSelected && !isCorrectOpt) btn.classList.add("dimmed");
    btn.disabled = true;
  });

  if (roundNumber === 1 && q._baseIndex != null && firstRoundAns[q._baseIndex] == null) {
    firstRoundAns[q._baseIndex] = selectedIdx;
    attemptedFirst++;
    if (isCorrect) marksCorrectFirst++; else marksWrongFirst++;
  }

  if (isCorrect) {
    currentStreak++;
    if (currentStreak > bestStreak) bestStreak = currentStreak;
  } else {
    currentStreak = 0;
  }

  if (nextBtn && !quizFinished) nextBtn.disabled = false;
  updateStats();
  updateProgress();

  cfg_autoSkip = getBoolSetting("set_autoSkip", true);
  if (cfg_autoSkip) {
    const delay = isCorrect ? 600 : 3000;
    autoNextTimeout = setTimeout(() => {
      autoNextTimeout = null;
      if (!quizFinished) goToNextQuestion(false);
    }, delay);
  }
}

  /* ========== NAVIGATION / ROUNDS ========== */
  function goToNextQuestion(fromTimer) {
    if (!currentQuestions.length) return;
    if (!fromTimer && answers[currentIndex] == null && !quizFinished) return;

    if (currentIndex < currentQuestions.length - 1) {
      currentIndex++;
      renderQuestion();
      startTimerForCurrentQuestion();
      return;
    }

    finishRound();
  }

  function goToPrevQuestion() {
    if (!currentQuestions.length || currentIndex === 0) return;
    clearTimer();
    clearAutoNext();
    currentIndex--;
    renderQuestion();
    startTimerForCurrentQuestion();
  }

  function finishRound() {
    clearTimer();
    clearAutoNext();

    if (roundNumber === 1 && marks == null) {
      marks = computeMarks();
    }

    const remaining = [];
    baseQuestions.forEach((q, idx) => {
      if (!mastered[idx]) remaining.push(idx);
    });

    if (remaining.length > 0) {
      roundNumber++;
      currentQuestions = remaining.map(i => baseQuestions[i]);
      cfg_randomizeQuestions = getBoolSetting("set_randomizeQuestions", true);
      if (cfg_randomizeQuestions && !(orderToggle && orderToggle.checked)) {
        shuffleArray(currentQuestions);
      }
      answers = Array(currentQuestions.length).fill(null);
      currentIndex = 0;
      currentStreak = 0;
      updateStats();
      renderQuestion();
      startTimerForCurrentQuestion();
      return;
    }

    endQuiz();
  }


  function endQuiz() {
if (examTimerInterval) {
  clearInterval(examTimerInterval);
  examTimerInterval = null;
}

    quizFinished = true;
    clearTimer();
    clearAutoNext();
    if (timerDisplay) timerDisplay.textContent = "--";

    if (markSep)       markSep.style.display = "block";
    if (marksLine)     marksLine.style.display = "block";
    if (reviewActions) reviewActions.style.display = "flex";
    if (reviewBtn)     reviewBtn.disabled = false;
    if (savePdfBtn)    savePdfBtn.disabled = false;

    if (prevBtn) prevBtn.disabled = (currentIndex === 0);
    if (nextBtn) nextBtn.disabled = (currentIndex === currentQuestions.length - 1);

    updateStats();
  }

  if (nextBtn) nextBtn.addEventListener("click", () => {
    clearAutoNext();
    goToNextQuestion(false);
  });
  if (prevBtn) prevBtn.addEventListener("click", () => {
    clearAutoNext();
    goToPrevQuestion();
  });

  /* ========== REVIEW + PDF ========== */

function buildReviewSection() {
  if (!reviewSection) return;
  reviewSection.innerHTML = "";

  if (!baseQuestions.length) {
    reviewSection.textContent = "No questions to review.";
    return;
  }

  // ---------- 1st PAGE: COVER / GREETING (same as index.html) ----------
  const cover = document.createElement("div");
  cover.className = "review-cover";

  const now = new Date();
  const timeStr = now.toLocaleTimeString([], {
    hour: "2-digit",
    minute: "2-digit",
  });
  const dateStr = now.toLocaleDateString();

  cover.innerHTML = `
    <div class="review-cover-time">
      <div>Time: ${timeStr}</div>
      <div>Date: ${dateStr}</div>
    </div>

    <h1 class="review-cover-title">TESTY ‚Äì Your Practice Report üìò</h1>

    <p class="review-cover-text">
      You're working hard, and that already puts you far ahead. Stay consistent, stay
      disciplined, stay hungry. You are going to crack this. I believe you will, seriously.
      Best of LUCK! ‚ù§Ô∏è Mujhe Pata Hai Tum Kar Loge.
    </p>

    <p class="review-cover-sign">
      Made with Love ‚ù§Ô∏è Kunal
    </p>
  `;
  reviewSection.appendChild(cover);

  // ---------- QUESTIONS LIST (same style classes as index.html) ----------
  baseQuestions.forEach((q, idx) => {
    // IMPORTANT: rtp_mtp uses firstRoundAns (not firstRoundAnswers)
    const userAns = firstRoundAns[idx];
    const isCorrectFirst = userAns === q.correctIndex;

    const block = document.createElement("div");
    block.className = "review-question";

    const qText = document.createElement("div");
    qText.className = "review-q-text";
    qText.textContent = `Q${idx + 1}. ${q.text}`;
    block.appendChild(qText);

    q.options.forEach((opt, optIndex) => {
      const optDiv = document.createElement("div");
      optDiv.className = "review-option";

      const letter = String.fromCharCode(65 + optIndex);
      optDiv.textContent = `${letter}. ${opt}`;

      const isCorrect = optIndex === q.correctIndex;
      const isSelected = userAns === optIndex;

      if (isSelected && isCorrect) {
        optDiv.classList.add("correct");
      } else if (isSelected && !isCorrect) {
        optDiv.classList.add("wrong");
      } else if (!isSelected && isCorrect) {
        optDiv.classList.add("correct");
      }

      block.appendChild(optDiv);
    });

    if (userAns == null) {
      const info = document.createElement("div");
      info.className = "review-not-attempted";
      info.textContent = "Not attempted in first round.";
      block.appendChild(info);
    }

    // Border colour ‚Äì uses same CSS classes as index.html
    if (userAns == null) {
      block.classList.add("review-border-neutral");
    } else if (isCorrectFirst) {
      block.classList.add("review-border-correct");
    } else {
      block.classList.add("review-border-wrong");
    }

    reviewSection.appendChild(block);
  });
}

// Review button ‚Äì screen pe bhi same content dikhayega (same as index.html)
if (reviewBtn && reviewSection) {
  reviewBtn.addEventListener("click", () => {
    if (!quizFinished) return;

    if (reviewSection.style.display === "block") {
      reviewSection.style.display = "none";
    } else {
      buildReviewSection();
      reviewSection.style.display = "block";
      reviewSection.scrollTop = 0;
    }
  });
}

// PDF button ‚Äì cover + questions print karega (same simple system as index.html)
if (savePdfBtn && reviewSection) {
  savePdfBtn.addEventListener("click", () => {
    if (!quizFinished) return; // index.html jaisa simple guard

    buildReviewSection();
    reviewSection.style.display = "block";
    reviewSection.scrollTop = 0;

    // No extra body class, no timeout => avoids extra blank page
    window.print();
  });
}
  
// Minimal theme (safe)
const minimalSwitch = document.getElementById("minimalSwitch");
const minimalSaved = localStorage.getItem("minimalTheme") === "1";

if (minimalSaved) {
  document.body.classList.add("minimal-theme");
}

if (minimalSwitch) {
  minimalSwitch.checked = minimalSaved;
  minimalSwitch.addEventListener("change", () => {
    const on = minimalSwitch.checked;
    localStorage.setItem("minimalTheme", on ? "1" : "0");
    document.body.classList.toggle("minimal-theme", on);
  });
}
  // initial UI
  updateStats();
  updateProgress();
  renderQuestion();  // "Select an attempt to start."



})();
</script>
<script>
  const currentPage = "rtp";   // is page par ho
</script>
<script src="shared.js"></script>
<!-- Tiny toast for settings -->
<div id="settingToast" class="setting-toast">
  <div class="setting-toast-bar" id="settingToastBar"></div>
  <span id="settingToastText"></span>
</div>
<!-- XP transferred toast -->
<div id="xpToast" class="xp-toast">Transferred!</div>
 <footer class="simple-footer">
  <div>Made with ‚ô•Ô∏è</div>
  <div>Kunal Sharma ‚Ä¢ CA Foundation</div>
</footer>
</body>
</html>